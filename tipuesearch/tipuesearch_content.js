var tipuesearch = {"pages":[{"text":"fortperc Introduction This library consists of two main modules: hk , which contains an implementation of the Hoshen-Kopelman algorithm. percolation , which contains procedures for doing various percolation related measurements, such as the probability for having a percolating cluster (one which allows transport across the system). Additionally, there is utilities , a small module containing useful procedures such as linspace and linfit . Developer Info Anders Johansson Computational Physics M.Sc. student at UiO.","tags":"home","loc":"index.html","title":" fortperc "},{"text":"Files dependent on this one sourcefile~~utilities.f90~~AfferentGraph sourcefile~utilities.f90 utilities.f90 sourcefile~randomwalk.f90 randomwalk.f90 sourcefile~randomwalk.f90->sourcefile~utilities.f90 sourcefile~percolation.f90 percolation.f90 sourcefile~randomwalk.f90->sourcefile~percolation.f90 sourcefile~percolation.f90->sourcefile~utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules utilities Source Code utilities.f90 Source Code module utilities !! Useful procedures when doing percolation. implicit none integer , parameter :: dp = kind ( 1.0d0 ) !! Kind used for all **real** variables. contains function stringfromint ( x ) !! Make a string of \"correct\" length from a positive integer. character ( len = :), allocatable :: stringfromint !! String containing the given integer, without spaces. integer , intent ( in ) :: x !! Positive integer to be converted. integer :: numdigits numdigits = int ( log10 ( real ( x ))) + 1 allocate ( character ( len = numdigits ) :: stringfromint ) write ( unit = stringfromint , fmt = \"(i0)\" ) x end function function linspace ( a , b , N ) !! Create an array of **N** linearly spaced *values* (not intervals) !! from **a** to **b**. !! Similar to [`numpy.linspace(a, b, N)`](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html). integer , intent ( in ) :: N !! Number of values (not intervals). real ( kind = dp ), intent ( in ) :: a !! Lower endpoint. real ( kind = dp ), intent ( in ) :: b !! Upper endpoint. real ( kind = dp ), dimension (:), allocatable :: linspace !! Array of linearly spaced values. real ( kind = dp ) :: dx integer :: i dx = ( b - a ) / ( N - 1 ) linspace = [ ( a + i * dx , i = 0 , N - 1 ) ] end function subroutine linfit ( x , y , slope , const ) !! Compute a linear fit for the given data, return !! the slope and the constant term. !! `dgels` from LAPACK solves the linear least squares problem. real ( kind = dp ), dimension (:), intent ( in ) :: x , y !! Values to be fitted. real ( kind = dp ), intent ( inout ) :: slope !! \\a\\ in \\y=ax+b\\. real ( kind = dp ), intent ( inout ) :: const !! \\b\\ in \\y=ax+b\\. real ( kind = dp ), dimension (:,:), allocatable :: A real ( kind = dp ), dimension (:), allocatable :: b , work integer :: lda , ldb , lwork , info , m m = size ( x ) allocate ( A ( m , 2 )) allocate ( b ( m )) allocate ( work ( 1 )) A (:, 1 ) = x (:) A (:, 2 ) = 1 b (:) = y (:) lda = m ldb = m lwork = - 1 call dgels ( \"N\" , m , 2 , 1 , A , lda , b , ldb , work , lwork , info ) lwork = int ( work ( 1 )) deallocate ( work ) allocate ( work ( lwork )) call dgels ( \"N\" , m , 2 , 1 , A , lda , b , ldb , work , lwork , info ) slope = b ( 1 ) const = b ( 2 ) if ( info /= 0 ) then error stop \"Problems with least squares\" endif end subroutine function find_intersection ( array1 , array2 , num_labels ) result ( intersect_label ) !! Find the common element in two arrays, given a total of !! **num_labels** unique elements. Used by [[find_spanning_cluster]]. integer , dimension (:), intent ( in ) :: array1 , array2 !! Array to analyse. integer , intent ( in ) :: num_labels !! The known number of unique non-zero elements. integer :: intersect_label !! The first non-zero common element. integer :: L , i logical , dimension (:), allocatable :: label_found L = size ( array1 ) allocate ( label_found ( 0 : num_labels )) !/intersectsnippetstart/! label_found ( 0 : num_labels ) = . false . do i = 1 , L label_found ( array1 ( i )) = . true . end do do i = 1 , L if ( array2 ( i ) /= 0 . and . label_found ( array2 ( i ))) then intersect_label = array2 ( i ) return end if end do !/intersectsnippetend/! intersect_label = - 1 end function subroutine find_random_point ( matrix , i , j ) !! Find a random position on **matrix** such that !! **matrix(i, j)** is `.true.`. logical , dimension (:,:), intent ( in ) :: matrix !! Matrix whose `.true.` values are allowed positions for the !! random walker. integer , intent ( out ) :: i , j !! Returned random point on **matrix**. integer :: L real ( kind = dp ) :: x0_real , y0_real L = size ( matrix , 1 ) ! Find random starting point. do call random_number ( x0_real ) call random_number ( y0_real ) x0_real = L * x0_real + 1 y0_real = L * y0_real + 1 i = int ( x0_real ) j = int ( y0_real ) if ( matrix ( i , j )) then return end if end do end subroutine subroutine periodic_wraparound ( x , L ) integer , intent ( inout ) :: x integer , intent ( in ) :: L if ( x == 0 ) then !write(*,*) \"before:\", x x = L !write(*,*) \"after:\", x else if ( x == L + 1 ) then !write(*,*) \"before:\", x x = 1 !write(*,*) \"after:\", x end if end subroutine function mark_percolating_with_periodic ( label_matrix , & percolating_label , & num_clusters ) & result ( matrix ) !! Return a `logical` matrix where the `.true.` values are the sites !! belonging to the percolating cluster, when periodic boundary !! conditions are considered. integer , dimension (:,:), intent ( in ) :: label_matrix !! Labelled matrix from [[label]] or [[hoshen_kopelman]]. integer , intent ( in ) :: percolating_label !! Known label of the percolating cluster. integer , intent ( in ) :: num_clusters !! The known number of clusters. logical , dimension (:,:), allocatable :: matrix !! Matrix where the `.true.` values are the sites belonging to !! the percolating cluster with periodic boundary conditions. integer :: L , i , j logical , dimension (:), allocatable :: connected_to_percolating L = size ( label_matrix , 1 ) allocate ( matrix ( L , L )) allocate ( connected_to_percolating ( 0 : num_clusters )) connected_to_percolating (:) = . false . connected_to_percolating ( percolating_label ) = . true . do i = 1 , L if ( label_matrix ( i , 1 ) == percolating_label ) then connected_to_percolating ( label_matrix ( i , L )) = . true . end if if ( label_matrix ( i , L ) == percolating_label ) then connected_to_percolating ( label_matrix ( i , 1 )) = . true . end if if ( label_matrix ( 1 , i ) == percolating_label ) then connected_to_percolating ( label_matrix ( L , i )) = . true . end if if ( label_matrix ( L , i ) == percolating_label ) then connected_to_percolating ( label_matrix ( 1 , i )) = . true . end if end do connected_to_percolating ( 0 ) = . false . !$omp parallel do do j = 1 , L do i = 1 , L matrix ( i , j ) = connected_to_percolating ( label_matrix ( i , j )) end do end do !$omp end parallel do end function end module","tags":"","loc":"sourcefile/utilities.f90.html","title":"utilities.f90 – fortperc"},{"text":"This file depends on sourcefile~~randomwalk.f90~~EfferentGraph sourcefile~randomwalk.f90 randomwalk.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~randomwalk.f90->sourcefile~utilities.f90 sourcefile~percolation.f90 percolation.f90 sourcefile~randomwalk.f90->sourcefile~percolation.f90 sourcefile~percolation.f90->sourcefile~utilities.f90 sourcefile~hk.f90 hk.f90 sourcefile~percolation.f90->sourcefile~hk.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules randomwalk Source Code randomwalk.f90 Source Code module randomwalk use utilities use percolation implicit none private :: find_random_point contains function one_random_walker ( matrix , num_steps ) result ( displacement ) !! Let one random walker do **num_steps** jumps on the `.true.` !! values of **matrix**. The initial position is randomly selected. logical , dimension (:,:), intent ( in ) :: matrix !! Matrix whose `.true.` values are allowed positions for the !! random walker. integer :: num_steps !! Number of steps for the random walker to take. real ( kind = dp ), dimension (:,:), allocatable :: displacement !! Array of displacements, which has dimension !! 2 \\\\times\\ (**num_steps** + 1), !! and should logically have `dimension(2,0:num_steps)`, such that !! the i'th column contains the displacement after i steps. !! Averaged over all systems and all walkers. integer :: x0 , y0 , x , y , x_new , y_new , dx , dy , L , i , direction real ( kind = dp ) :: real_direction ! North - East - South - West integer , dimension ( 4 ) :: dxs = [ 0 , 1 , 0 , - 1 ] integer , dimension ( 4 ) :: dys = [ 1 , 0 , - 1 , 0 ] L = size ( matrix , 1 ) allocate ( displacement ( 2 , 0 : num_steps )) displacement (:,:) = 0 call find_random_point ( matrix , x0 , y0 ) x = x0 y = y0 do i = 1 , num_steps call random_number ( real_direction ) direction = int ( 4 * real_direction + 1 ) dx = dxs ( direction ) dy = dys ( direction ) x_new = x + dx y_new = y + dy call periodic_wraparound ( x_new , L ) call periodic_wraparound ( y_new , L ) if ( matrix ( x_new , y_new )) then x = x_new y = y_new displacement (:, i ) = displacement (:, i - 1 ) + [ dx , dy ] else displacement (:, i ) = displacement (:, i - 1 ) end if end do end function function random_walkers ( p , L , num_systems , num_walkers , num_steps ) result ( displacement ) !! Start **num_walkers** on the percolating cluster of each of **num_systems** !! systems, and return the averaged displacement. real ( kind = dp ), intent ( in ) :: p !! The probability for each site to allow transport. integer , intent ( in ) :: L !! The system size. integer , intent ( in ) :: num_systems !! The number of systems over which to average. integer , intent ( in ) :: num_walkers !! The number of random walkers for each system over which to average. integer , intent ( in ) :: num_steps !! The number of steps which the random walkers take. real ( kind = dp ), dimension (:), allocatable :: displacement !! Array of squared displacements, which has dimension !! (**num_steps** + 1), !! and should logically have `dimension(0:num_steps)`, such that !! the i'th element contains the displacement after i steps. !! Averaged over all systems and all walkers. logical , dimension (:,:), allocatable :: binary_matrix , spanning_cluster integer , dimension (:,:), allocatable :: label_matrix real ( kind = dp ), dimension (:,:), allocatable :: tmp_displacement integer :: i , num_spanning_clusters , num_clusters , spanning_cluster_label allocate ( displacement ( 0 : num_steps )) displacement (:) = 0 num_spanning_clusters = 0 do while ( num_spanning_clusters < num_systems ) binary_matrix = create_binary_matrix ( p , L ) call label ( binary_matrix , label_matrix , num_clusters ) spanning_cluster_label = find_spanning_cluster ( label_matrix , num_clusters ) if ( spanning_cluster_label < 1 ) then cycle end if num_spanning_clusters = num_spanning_clusters + 1 spanning_cluster = mark_percolating_with_periodic ( & label_matrix , spanning_cluster_label , & num_clusters ) !$omp parallel do private(tmp_displacement) reduction(+:displacement) do i = 1 , num_walkers tmp_displacement = one_random_walker ( spanning_cluster , num_steps ) displacement (:) = displacement (:) + sum ( tmp_displacement (:,:) ** 2 , dim = 1 ) end do !$omp end parallel do end do displacement (:) = displacement (:) / ( num_walkers * num_systems ) end function function probability_distribution ( p , L , num_steps , num_walkers , num_systems , num_hists ) & result ( result_hist ) !! Start **num_walkers** on the percolating cluster of each of **num_systems** !! systems, and compute **num_hists** histograms of the distribution !! of particles. real ( kind = dp ), intent ( in ) :: p !! The probability for each site to allow transport. integer , intent ( in ) :: L !! The system size. integer , intent ( in ) :: num_systems !! The number of systems over which to average. integer , intent ( in ) :: num_walkers !! The number of random walkers for each system over which to average. integer , intent ( in ) :: num_steps !! The number of steps which the random walkers take. integer , intent ( in ) :: num_hists !! The number of histograms to be returned. real ( kind = dp ), dimension (:,:), allocatable :: result_hist !! Array of histograms. The first row contains the centres of the !! bins, while the remaining **num_hists+1** rows each contain !! one histogram. logical , dimension (:,:), allocatable :: binary_matrix , spanning_cluster integer , dimension (:,:), allocatable :: label_matrix integer , dimension (:), allocatable :: hist_indices integer :: hist_dist , i , j , maxdist , x_index , y_index real ( kind = dp ), dimension (:,:), allocatable :: tmp_displacement , tmp_hist integer , dimension (:,:,:), allocatable :: displacement , absdisplacement integer :: num_spanning_clusters , num_clusters , spanning_cluster_label allocate ( displacement ( 2 , 0 : num_hists , num_walkers * num_systems )) hist_dist = num_steps / num_hists allocate ( hist_indices ( 0 : num_hists )) hist_indices (:) = [( hist_dist * i , i = 0 , num_hists )] num_spanning_clusters = 0 do while ( num_spanning_clusters < num_systems ) binary_matrix = create_binary_matrix ( p , L ) call label ( binary_matrix , label_matrix , num_clusters ) spanning_cluster_label = find_spanning_cluster ( label_matrix , num_clusters ) if ( spanning_cluster_label < 1 ) then cycle end if num_spanning_clusters = num_spanning_clusters + 1 spanning_cluster = mark_percolating_with_periodic ( & label_matrix , spanning_cluster_label , & num_clusters ) !$omp parallel do private(tmp_displacement) do i = 1 , num_walkers tmp_displacement = one_random_walker ( spanning_cluster , num_steps ) do j = 0 , num_hists associate ( hist_index => hist_indices ( j ), & indx => ( num_spanning_clusters - 1 ) * num_walkers + i ) displacement (:, j , indx ) = tmp_displacement (:, hist_index + 1 ) end associate end do end do !$omp end parallel do end do allocate ( absdisplacement ( 2 , 0 : num_hists , num_walkers * num_systems )) !$omp parallel workshare absdisplacement (:,:,:) = abs ( displacement (:,:,:)) maxdist = maxval ( absdisplacement ) !$omp end parallel workshare allocate ( result_hist ( - 1 : num_hists , - maxdist : maxdist )) result_hist ( - 1 ,:) = [( i , i = - maxdist , maxdist )] result_hist ( 0 :,:) = 0 !$omp parallel do private(x_index, y_index) reduction(+:result_hist) do i = 0 , num_hists do j = 1 , num_systems * num_walkers associate ( x => displacement ( 1 , i , j ), & y => displacement ( 2 , i , j )) result_hist ( i , x ) = result_hist ( i , x ) + 1 result_hist ( i , y ) = result_hist ( i , y ) + 1 end associate end do end do !$omp end parallel do result_hist ( 0 :,:) = result_hist ( 0 :,:) / ( 2.0d0 * num_systems * num_walkers ) end function end module randomwalk","tags":"","loc":"sourcefile/randomwalk.f90.html","title":"randomwalk.f90 – fortperc"},{"text":"This file depends on sourcefile~~percolation.f90~~EfferentGraph sourcefile~percolation.f90 percolation.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~percolation.f90->sourcefile~utilities.f90 sourcefile~hk.f90 hk.f90 sourcefile~percolation.f90->sourcefile~hk.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~percolation.f90~~AfferentGraph sourcefile~percolation.f90 percolation.f90 sourcefile~randomwalk.f90 randomwalk.f90 sourcefile~randomwalk.f90->sourcefile~percolation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules percolation Source Code percolation.f90 Source Code module percolation !! A module with procedures for calculating various properties which !! are interesting when doing numerical percolation experiments. use utilities use hk implicit none private :: has_spanning_cluster_one_sample , spanning_density_one_sample , & label_recursively , growcluster real ( kind = dp ), parameter :: pc = 0.592746 !! Known critical probability for a two-dimensional site-percolating !! system. contains function create_binary_matrix ( p , L ) result ( binary_matrix ) !! Create a random, binary (`logical`) matrix, !! which can be used in percolation experiments. logical , dimension (:,:), allocatable :: binary_matrix !! Randomly created matrix, where each element is `.true.` !! or `.false.` if a randomly generated number is smaller !! or greater than p. real ( kind = dp ), intent ( in ) :: p !! Probability for each matrix element to be `.true.`. integer , intent ( in ) :: L real ( kind = dp ), dimension (:,:), allocatable :: p_matrix allocate ( p_matrix ( L , L )) call random_seed () call random_number ( p_matrix ) binary_matrix = p_matrix < p end function subroutine label ( matrix , labelled_matrix , num_labels ) !! Alternative interface to the Hoshen-Kopelman algorithm !! from the hk module, which uses a binary matrix created !! by [[create_binary_matrix]]. logical , dimension (:,:), intent ( in ) :: matrix !! Binary matrix where clusters will be identified. integer , dimension (:,:), allocatable , intent ( out ) :: labelled_matrix !! Integer matrix which will store the labels of each cluster. !! Reallocated if necessary. integer , intent ( out ) :: num_labels !! Overwritten with the total number of disjoint clusters. integer :: L L = size ( matrix , 1 ) if (. not . allocated ( labelled_matrix )) then allocate ( labelled_matrix ( L , L )) else if ( size ( labelled_matrix , 1 ) /= L ) then deallocate ( labelled_matrix ) allocate ( labelled_matrix ( L , L )) endif where ( matrix ) labelled_matrix = 1 else where labelled_matrix = 0 end where num_labels = hoshen_kopelman ( labelled_matrix ) end subroutine function find_sizes ( labelled_matrix , num_labels ) result ( sizes ) !! Count the number of sites belonging to each cluster !! in the labelled matrix. integer , dimension (:), allocatable :: sizes !! Array of cluster sizes. The i'th element is the size of !! the cluster with label i. integer , dimension (:,:), intent ( in ) :: labelled_matrix !! Integer matrix with labelled clusters, resulting from !! the Hoshen-Kopelman algorithm. integer , intent ( in ) :: num_labels !! The known number of clusters. integer :: L , i , j L = size ( labelled_matrix , 1 ) allocate ( sizes ( num_labels )) sizes (:) = 0 do j = 1 , L do i = 1 , L associate ( label => labelled_matrix ( i , j )) if ( label /= 0 ) then sizes ( label ) = sizes ( label ) + 1 end if end associate end do end do end function subroutine cluster_number_density ( p , L , num_samples , bin_mids , results , binsize_base ) !! Calculate the number density of clusters with different sizes. !! The cluster number density is defined as !! \\\\begin{equation} !!      n(s,p) = \\sum_{\\text{MC-samples}} !!                   \\frac{\\text{number of clusters with size }s} !!                        {L&#94;2\\cdot\\text{number of MC-samples}}. !! \\\\end{equation} !! Direct calculations will usually give bad results, as there !! will be very few !! clusters with large sizes compared to the numbers of clusters !! with small sizes. This is circumvented by doing logarithmic !! binning and averaging, i.e. !! \\\\begin{equation} !!      n\\left([s+\\Delta s),p\\right) = \\sum_{\\text{MC-samples}} !!                   \\frac{\\text{number of clusters with size }s !!                         \\in[s,s+\\Delta s)} !!                        {\\Delta s\\cdot L&#94;2\\cdot\\text{number of MC-samples}}, !!      \\label{eq:nsp} !! \\\\end{equation} !! where \\\\Delta s\\ are logarithmically distributed. After execution, !! **bin_mids** will contain the centres of the bins. integer , intent ( in ) :: L !! Percolating systems will be \\L\\times L\\. integer , intent ( in ) :: num_samples !! Results will be averaged over this number of Monte Carlo-samples. !! Sampling is parallelised. real ( kind = dp ), intent ( in ) :: p !! Probability for a given site to allow transport. real ( kind = dp ), intent ( in ), optional :: binsize_base !! The edges of the logarithmically distributed bins will be !! integer powers of this number. Default: 1.5. real ( kind = dp ), dimension (:), intent ( out ), allocatable :: bin_mids !! Centres of bins. real ( kind = dp ), dimension (:), intent ( out ), allocatable :: results !! Cluster number density in \\eqref{eq:nsp}. integer :: num_bins , i , j , num_labels , sizeindex , spanning_label real ( kind = dp ) :: a , loga logical , dimension (:,:), allocatable :: binary_matrix integer , dimension (:,:), allocatable :: label_matrix integer , dimension (:), allocatable :: clustersizes , histogram real ( kind = dp ), dimension (:), allocatable :: bin_edges , bin_sizes if ( present ( binsize_base )) then a = binsize_base else a = 1.5d0 end if !/cndstart/! loga = log ( a ) num_bins = ceiling ( log ( 1.0d0 * L ** 2 ) / loga ) bin_edges = a ** [( i , i = 0 , num_bins )] bin_mids = 0.5 * ( bin_edges ( 1 : num_bins ) + bin_edges ( 2 : num_bins + 1 )) bin_sizes = bin_edges ( 2 : num_bins + 1 ) - bin_edges ( 1 : num_bins ) allocate ( histogram ( 1 : num_bins )) histogram = 0 !$omp  parallel do & !$omp& private(binary_matrix, label_matrix, num_labels, & !$omp&         clustersizes, spanning_label, sizeindex) & !$omp& reduction(+:histogram) do i = 1 , num_samples binary_matrix = create_binary_matrix ( p , L ) call label ( binary_matrix , label_matrix , num_labels ) clustersizes = find_sizes ( label_matrix , num_labels ) spanning_label = find_spanning_cluster ( label_matrix , num_labels ) do j = 1 , num_labels if ( j /= spanning_label ) then sizeindex = floor ( log ( 1.0d0 * clustersizes ( j )) / loga ) + 1 histogram ( sizeindex ) = histogram ( sizeindex ) + 1 end if end do end do !$omp end parallel do results = histogram / ( L ** 2 * num_samples * bin_sizes ) !/cndend/! end subroutine function find_spanning_cluster ( labelled_matrix , num_labels ) result ( spanning_label ) !! Find the label of the percolating cluster, i.e. the one spanning from !! one side of the system to the opposing side. integer :: spanning_label !! Label of the percolating cluster. -1 if no percolating cluster is found. integer , dimension (:,:), intent ( in ) :: labelled_matrix !! Labelled matrix of clusters from [[hoshen_kopelman]]/[[label]]. integer , intent ( in ) :: num_labels !! Known number of clusters. integer :: L L = size ( labelled_matrix , 1 ) spanning_label = find_intersection ( labelled_matrix (:, 1 ), labelled_matrix (:, L ), num_labels ) if ( spanning_label == - 1 ) then spanning_label = find_intersection ( labelled_matrix ( 1 ,:), labelled_matrix ( L ,:), num_labels ) end if end function function spanning_density_one_sample ( p , L ) result ( spanning_density ) real ( kind = dp ) :: spanning_density real ( kind = dp ), intent ( in ) :: p integer , intent ( in ) :: L logical , dimension (:,:), allocatable :: binary_matrix integer , dimension (:,:), allocatable :: labelled_matrix integer :: num_labels , spanning_label binary_matrix = create_binary_matrix ( p , L ) call label ( binary_matrix , labelled_matrix , num_labels ) spanning_label = find_spanning_cluster ( labelled_matrix , num_labels ) if ( spanning_label == - 1 ) then spanning_density = 0 return end if spanning_density = count ( labelled_matrix == spanning_label ) / real ( L ** 2 , kind = dp ) end function function spanning_density ( p , L , num_samples ) !! Density of the spanning/percolating cluster, i.e. !! the number of sites on the percolating cluster divided by \\L&#94;2\\. !! Averaged over **num_samples** Monte Carlo samples (with OpenMP). real ( kind = dp ) :: spanning_density !! The number of sites on the spanning cluster divided by \\L&#94;2\\. real ( kind = dp ), intent ( in ) :: p !! The probability for a site to allow transport. integer , intent ( in ) :: L !! The size of the system. integer , intent ( in ) :: num_samples !! The number of Monte Carlo samples. integer :: i real ( kind = dp ), dimension (:), allocatable :: results allocate ( results ( num_samples )) !$omp parallel do do i = 1 , num_samples results ( i ) = spanning_density_one_sample ( p , L ) end do !$omp end parallel do spanning_density = sum ( results ) / num_samples end function function has_spanning_cluster_one_sample ( p , L ) result ( has_spanning ) logical :: has_spanning real ( kind = dp ), intent ( in ) :: p integer , intent ( in ) :: L logical , dimension (:,:), allocatable :: binary_matrix integer , dimension (:,:), allocatable :: labelled_matrix integer :: num_labels , spanning_label binary_matrix = create_binary_matrix ( p , L ) call label ( binary_matrix , labelled_matrix , num_labels ) spanning_label = find_spanning_cluster ( labelled_matrix , num_labels ) has_spanning = spanning_label /= - 1 end function function spanning_probability ( p , L , num_samples ) !! Calculate the probability of having a spanning/percolating cluster, given !! a system size **L** and probability for a site to have transport **p**. real ( kind = dp ) :: spanning_probability !! The probability of having a percolating cluster, calculated as the number !! of times a percolating cluster is found, divided by the number of attempts !! (**num_samples**). real ( kind = dp ), intent ( in ) :: p !! Probability for a site to allow transport. integer , intent ( in ) :: L !! Size of the system. integer , intent ( in ) :: num_samples !! Number of Monte Carlo samples. integer :: i logical , dimension (:), allocatable :: results allocate ( results ( num_samples )) !$omp parallel do do i = 1 , num_samples results ( i ) = has_spanning_cluster_one_sample ( p , L ) end do !$omp end parallel do spanning_probability = count ( results ) / real ( num_samples , kind = dp ) end function function spanning_probability_inverse ( x , L , num_samples , tolerance ) result ( p_x ) !! Find the inverse of [[spanning_probability]] by use !! of the bisection method. real ( kind = dp ), intent ( in ) :: x !! The value of [[spanning_probability]] for which the inverse !! is calculated. real ( kind = dp ), intent ( in ) :: tolerance !! Tolerance of approximation. The return value is within !! **tolerance**/2 of the correct (but numerical) value. integer , intent ( in ) :: L !! Size of the system. integer , intent ( in ) :: num_samples !! Number of Monte Carlo samples to use when evaluating [[spanning_probability]]. real ( kind = dp ) :: p_x !! The inverse of [[spanning_probability]]. If [[spanning_probability]] is !! denoted \\\\Pi(p,L)\\, this function returns \\p\\ such !! that \\\\Pi(p,L)=x\\. real ( kind = dp ) :: lower , upper , lowerPI , upperPI , mid , midPI !/invPIstart/! lower = 0 upper = 1 lowerPI = 0 upperPI = 1 do while ( upper - lower > tolerance ) mid = ( lower + upper ) / 2 midPI = spanning_probability ( mid , L , num_samples ) if ( midPI > x ) then upper = mid upperPI = midPI else lower = mid lowerPI = midPI end if end do p_x = mid !/invPIend/! end function !/labelsubroutinestart/! subroutine label_recursively ( matrix , labelled_matrix , num_labels ) logical , dimension (:,:), allocatable , intent ( in ) :: matrix integer , dimension (:,:), allocatable , intent ( inout ) :: labelled_matrix integer , intent ( inout ) :: num_labels integer :: L , i , j L = size ( matrix , 1 ) num_labels = 0 if (. not . allocated ( labelled_matrix )) then allocate ( labelled_matrix ( L , L )) end if labelled_matrix = 0 do j = 1 , L do i = 1 , L if ( matrix ( i , j ) . and . labelled_matrix ( i , j ) == 0 ) then num_labels = num_labels + 1 call growcluster ( matrix , labelled_matrix , i , j , num_labels ) end if end do end do end subroutine !/labelsubroutineend/! !/growclustersubroutinestart/! recursive subroutine growcluster ( matrix , labelled_matrix , i , j , label ) logical , dimension (:,:), allocatable , intent ( in ) :: matrix integer , dimension (:,:), allocatable , intent ( inout ) :: labelled_matrix integer , intent ( in ) :: i , j , label integer :: L L = size ( matrix , 1 ) labelled_matrix ( i , j ) = label if ( i < L ) then if ( matrix ( i + 1 , j ) . and . labelled_matrix ( i + 1 , j ) == 0 ) then call growcluster ( matrix , labelled_matrix , i + 1 , j , label ) end if end if if ( j < L ) then if ( matrix ( i , j + 1 ) . and . labelled_matrix ( i , j + 1 ) == 0 ) then call growcluster ( matrix , labelled_matrix , i , j + 1 , label ) end if end if if ( i > 1 ) then if ( matrix ( i - 1 , j ) . and . labelled_matrix ( i - 1 , j ) == 0 ) then call growcluster ( matrix , labelled_matrix , i - 1 , j , label ) end if end if if ( j > 1 ) then if ( matrix ( i , j - 1 ) . and . labelled_matrix ( i , j - 1 ) == 0 ) then call growcluster ( matrix , labelled_matrix , i , j - 1 , label ) end if end if end subroutine !/growclustersubroutineend/! end module percolation","tags":"","loc":"sourcefile/percolation.f90.html","title":"percolation.f90 – fortperc"},{"text":"Files dependent on this one sourcefile~~hk.f90~~AfferentGraph sourcefile~hk.f90 hk.f90 sourcefile~percolation.f90 percolation.f90 sourcefile~percolation.f90->sourcefile~hk.f90 sourcefile~randomwalk.f90 randomwalk.f90 sourcefile~randomwalk.f90->sourcefile~percolation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules hk Source Code hk.f90 Source Code module hk !! A module containing a Fortran implementation of the !! Hoshen-Kopelman algorithm, as well as the necessary !! union-find procedures. implicit none contains function hoshen_kopelman ( matrix ) result ( num_clusters ) !! Hoshen-Kopelman algorithm for labelling clusters on !! a binary matrix. !! !! The function takes in a binary matrix !! (zeros and positive numbers), labels the clusters of !! positive numbers and returns the total number of clusters !! found. The argument matrix is overwritten with the labels. integer , intent ( inout ), dimension (:,:) :: matrix !! The matrix to be labelled. integer :: num_clusters !! The total number of disjoint clusters labelled. integer :: m , n , i , j , up , left , label integer , dimension (:), allocatable :: labels , new_labels m = size ( matrix , 1 ) n = size ( matrix , 2 ) allocate ( labels ( m * n / 2 + 1 )) labels = 0 num_clusters = 0 do j = 1 , n do i = 1 , m if ( matrix ( i , j ) > 0 ) then if ( i == 1 ) then up = 0 else up = matrix ( i - 1 , j ) end if if ( j == 1 ) then left = 0 else left = matrix ( i , j - 1 ) end if ! New cluster if ( up == 0 . and . left == 0 ) then num_clusters = num_clusters + 1 labels ( num_clusters ) = num_clusters matrix ( i , j ) = num_clusters ! Site binds clusters else if ( up > 0 . and . left > 0 ) then matrix ( i , j ) = uf_union ( up , left , labels ) ! Only one neighbour else matrix ( i , j ) = max ( up , left ) end if end if end do end do allocate ( new_labels ( m * n / 2 + 1 )) new_labels = 0 num_clusters = 0 do j = 1 , n do i = 1 , m if ( matrix ( i , j ) > 0 ) then label = uf_find ( matrix ( i , j ), labels ) if ( new_labels ( label ) == 0 ) then num_clusters = num_clusters + 1 new_labels ( label ) = num_clusters end if matrix ( i , j ) = new_labels ( label ) end if end do end do end function function uf_find ( x , labels ) result ( y ) !! Union-Find find algorithm: !! Find the lowest corresponding label. !! Relabelling is done when necessary. integer , intent ( in ) :: x !! Label for which to find the lowest corresponding label. integer , dimension (:), intent ( inout ) :: labels !! List of labels. **labels(i)** points to the lowest !! corresponding label of label **i**. integer :: y , z , tmp y = x do while ( labels ( y ) /= y ) y = labels ( y ) end do tmp = x do while ( labels ( tmp ) /= tmp ) z = labels ( tmp ) labels ( tmp ) = y tmp = z end do end function function uf_union ( x , y , labels ) result ( canonical_label ) !! Union-Find union algorithm: !! Merge two labels, return the result. integer , intent ( in ) :: x , y !! Labels to merge. integer , dimension (:), intent ( inout ) :: labels !! List of labels. integer :: canonical_label canonical_label = uf_find ( y , labels ) labels ( uf_find ( x , labels )) = canonical_label end function end module hk","tags":"","loc":"sourcefile/hk.f90.html","title":"hk.f90 – fortperc"},{"text":"public function stringfromint(x) Make a string of \"correct\" length from a positive integer. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Positive integer to be converted. Return Value character(len=:),\n  allocatable String containing the given integer, without spaces. Contents None","tags":"","loc":"proc/stringfromint.html","title":"stringfromint – fortperc"},{"text":"public function linspace(a, b, N) Create an array of N linearly spaced values (not intervals)\n from a to b .\n Similar to numpy.linspace(a, b, N) . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a Lower endpoint. real(kind=dp), intent(in) :: b Upper endpoint. integer, intent(in) :: N Number of values (not intervals). Return Value real(kind=dp),\n  dimension(:),allocatable Array of linearly spaced values. Contents None","tags":"","loc":"proc/linspace.html","title":"linspace – fortperc"},{"text":"public function find_intersection(array1, array2, num_labels) result(intersect_label) Find the common element in two arrays, given a total of num_labels unique elements. Used by find_spanning_cluster . Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array1 Array to analyse. integer, intent(in), dimension(:) :: array2 Array to analyse. integer, intent(in) :: num_labels The known number of unique non-zero elements. Return Value integer The first non-zero common element. Called by proc~~find_intersection~~CalledByGraph proc~find_intersection find_intersection proc~find_spanning_cluster find_spanning_cluster proc~find_spanning_cluster->proc~find_intersection proc~probability_distribution probability_distribution proc~probability_distribution->proc~find_spanning_cluster proc~random_walkers random_walkers proc~random_walkers->proc~find_spanning_cluster proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~find_spanning_cluster Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_intersection.html","title":"find_intersection – fortperc"},{"text":"public function mark_percolating_with_periodic(label_matrix, percolating_label, num_clusters) result(matrix) Return a logical matrix where the .true. values are the sites\n belonging to the percolating cluster, when periodic boundary\n conditions are considered. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: label_matrix Labelled matrix from label or hoshen_kopelman . integer, intent(in) :: percolating_label Known label of the percolating cluster. integer, intent(in) :: num_clusters The known number of clusters. Return Value logical,\n  dimension(:,:),allocatable Matrix where the .true. values are the sites belonging to\n the percolating cluster with periodic boundary conditions. Called by proc~~mark_percolating_with_periodic~~CalledByGraph proc~mark_percolating_with_periodic mark_percolating_with_periodic proc~probability_distribution probability_distribution proc~probability_distribution->proc~mark_percolating_with_periodic proc~random_walkers random_walkers proc~random_walkers->proc~mark_percolating_with_periodic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mark_percolating_with_periodic.html","title":"mark_percolating_with_periodic – fortperc"},{"text":"public subroutine linfit(x, y, slope, const) Compute a linear fit for the given data, return\n the slope and the constant term. dgels from LAPACK solves the linear least squares problem. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Values to be fitted. real(kind=dp), intent(in), dimension(:) :: y Values to be fitted. real(kind=dp), intent(inout) :: slope a in y=ax+b. real(kind=dp), intent(inout) :: const b in y=ax+b. Calls proc~~linfit~~CallsGraph proc~linfit linfit dgels dgels proc~linfit->dgels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/linfit.html","title":"linfit – fortperc"},{"text":"public subroutine find_random_point(matrix, i, j) Find a random position on matrix such that matrix(i, j) is .true. . Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:) :: matrix Matrix whose .true. values are allowed positions for the\n random walker. integer, intent(out) :: i Returned random point on matrix . integer, intent(out) :: j Returned random point on matrix . Called by proc~~find_random_point~~CalledByGraph proc~find_random_point find_random_point proc~one_random_walker one_random_walker proc~one_random_walker->proc~find_random_point proc~probability_distribution probability_distribution proc~probability_distribution->proc~one_random_walker proc~random_walkers random_walkers proc~random_walkers->proc~one_random_walker Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_random_point.html","title":"find_random_point – fortperc"},{"text":"public subroutine periodic_wraparound(x, L) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: x integer, intent(in) :: L Called by proc~~periodic_wraparound~~CalledByGraph proc~periodic_wraparound periodic_wraparound proc~one_random_walker one_random_walker proc~one_random_walker->proc~periodic_wraparound proc~probability_distribution probability_distribution proc~probability_distribution->proc~one_random_walker proc~random_walkers random_walkers proc~random_walkers->proc~one_random_walker Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/periodic_wraparound.html","title":"periodic_wraparound – fortperc"},{"text":"public function one_random_walker(matrix, num_steps) result(displacement) Let one random walker do num_steps jumps on the .true. values of matrix . The initial position is randomly selected. Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:) :: matrix Matrix whose .true. values are allowed positions for the\n random walker. integer :: num_steps Number of steps for the random walker to take. Return Value real(kind=dp),\n  dimension(:,:),allocatable Array of displacements, which has dimension\n 2 \\times ( num_steps + 1),\n and should logically have dimension(2,0:num_steps) , such that\n the i'th column contains the displacement after i steps.\n Averaged over all systems and all walkers. Calls proc~~one_random_walker~~CallsGraph proc~one_random_walker one_random_walker proc~find_random_point find_random_point proc~one_random_walker->proc~find_random_point proc~periodic_wraparound periodic_wraparound proc~one_random_walker->proc~periodic_wraparound Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~one_random_walker~~CalledByGraph proc~one_random_walker one_random_walker proc~probability_distribution probability_distribution proc~probability_distribution->proc~one_random_walker proc~random_walkers random_walkers proc~random_walkers->proc~one_random_walker Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/one_random_walker.html","title":"one_random_walker – fortperc"},{"text":"public function random_walkers(p, L, num_systems, num_walkers, num_steps) result(displacement) Start num_walkers on the percolating cluster of each of num_systems systems, and return the averaged displacement. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p The probability for each site to allow transport. integer, intent(in) :: L The system size. integer, intent(in) :: num_systems The number of systems over which to average. integer, intent(in) :: num_walkers The number of random walkers for each system over which to average. integer, intent(in) :: num_steps The number of steps which the random walkers take. Return Value real(kind=dp),\n  dimension(:),allocatable Array of squared displacements, which has dimension\n ( num_steps + 1),\n and should logically have dimension(0:num_steps) , such that\n the i'th element contains the displacement after i steps.\n Averaged over all systems and all walkers. Calls proc~~random_walkers~~CallsGraph proc~random_walkers random_walkers proc~mark_percolating_with_periodic mark_percolating_with_periodic proc~random_walkers->proc~mark_percolating_with_periodic proc~label label proc~random_walkers->proc~label proc~create_binary_matrix create_binary_matrix proc~random_walkers->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~random_walkers->proc~find_spanning_cluster proc~one_random_walker one_random_walker proc~random_walkers->proc~one_random_walker proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~find_random_point find_random_point proc~one_random_walker->proc~find_random_point proc~periodic_wraparound periodic_wraparound proc~one_random_walker->proc~periodic_wraparound proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find var panprocrandom_walkersCallsGraph = svgPanZoom('#procrandom_walkersCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/random_walkers.html","title":"random_walkers – fortperc"},{"text":"public function probability_distribution(p, L, num_steps, num_walkers, num_systems, num_hists) result(result_hist) Start num_walkers on the percolating cluster of each of num_systems systems, and compute num_hists histograms of the distribution\n of particles. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p The probability for each site to allow transport. integer, intent(in) :: L The system size. integer, intent(in) :: num_steps The number of steps which the random walkers take. integer, intent(in) :: num_walkers The number of random walkers for each system over which to average. integer, intent(in) :: num_systems The number of systems over which to average. integer, intent(in) :: num_hists The number of histograms to be returned. Return Value real(kind=dp),\n  dimension(:,:),allocatable Array of histograms. The first row contains the centres of the\n bins, while the remaining num_hists+1 rows each contain\n one histogram. Calls proc~~probability_distribution~~CallsGraph proc~probability_distribution probability_distribution proc~mark_percolating_with_periodic mark_percolating_with_periodic proc~probability_distribution->proc~mark_percolating_with_periodic proc~label label proc~probability_distribution->proc~label proc~create_binary_matrix create_binary_matrix proc~probability_distribution->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~probability_distribution->proc~find_spanning_cluster proc~one_random_walker one_random_walker proc~probability_distribution->proc~one_random_walker proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~find_random_point find_random_point proc~one_random_walker->proc~find_random_point proc~periodic_wraparound periodic_wraparound proc~one_random_walker->proc~periodic_wraparound proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find var panprocprobability_distributionCallsGraph = svgPanZoom('#procprobability_distributionCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/probability_distribution.html","title":"probability_distribution – fortperc"},{"text":"public function create_binary_matrix(p, L) result(binary_matrix) Create a random, binary ( logical ) matrix,\n which can be used in percolation experiments. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p Probability for each matrix element to be .true. . integer, intent(in) :: L Return Value logical,\n  dimension(:,:),allocatable Randomly created matrix, where each element is .true. or .false. if a randomly generated number is smaller\n or greater than p. Called by proc~~create_binary_matrix~~CalledByGraph proc~create_binary_matrix create_binary_matrix proc~probability_distribution probability_distribution proc~probability_distribution->proc~create_binary_matrix proc~random_walkers random_walkers proc~random_walkers->proc~create_binary_matrix proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~create_binary_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/create_binary_matrix.html","title":"create_binary_matrix – fortperc"},{"text":"public function find_sizes(labelled_matrix, num_labels) result(sizes) Count the number of sites belonging to each cluster\n in the labelled matrix. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: labelled_matrix Integer matrix with labelled clusters, resulting from\n the Hoshen-Kopelman algorithm. integer, intent(in) :: num_labels The known number of clusters. Return Value integer,\n  dimension(:),allocatable Array of cluster sizes. The i'th element is the size of\n the cluster with label i. Called by proc~~find_sizes~~CalledByGraph proc~find_sizes find_sizes proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~find_sizes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_sizes.html","title":"find_sizes – fortperc"},{"text":"public function find_spanning_cluster(labelled_matrix, num_labels) result(spanning_label) Find the label of the percolating cluster, i.e. the one spanning from\n one side of the system to the opposing side. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: labelled_matrix Labelled matrix of clusters from hoshen_kopelman / label . integer, intent(in) :: num_labels Known number of clusters. Return Value integer Label of the percolating cluster. -1 if no percolating cluster is found. Calls proc~~find_spanning_cluster~~CallsGraph proc~find_spanning_cluster find_spanning_cluster proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~find_spanning_cluster~~CalledByGraph proc~find_spanning_cluster find_spanning_cluster proc~probability_distribution probability_distribution proc~probability_distribution->proc~find_spanning_cluster proc~random_walkers random_walkers proc~random_walkers->proc~find_spanning_cluster proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~find_spanning_cluster Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_spanning_cluster.html","title":"find_spanning_cluster – fortperc"},{"text":"public function spanning_density(p, L, num_samples) Density of the spanning/percolating cluster, i.e.\n the number of sites on the percolating cluster divided by L&#94;2.\n Averaged over num_samples Monte Carlo samples (with OpenMP). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p The probability for a site to allow transport. integer, intent(in) :: L The size of the system. integer, intent(in) :: num_samples The number of Monte Carlo samples. Return Value real(kind=dp) The number of sites on the spanning cluster divided by L&#94;2. Contents None","tags":"","loc":"proc/spanning_density.html","title":"spanning_density – fortperc"},{"text":"public function spanning_probability(p, L, num_samples) Calculate the probability of having a spanning/percolating cluster, given\n a system size L and probability for a site to have transport p . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p Probability for a site to allow transport. integer, intent(in) :: L Size of the system. integer, intent(in) :: num_samples Number of Monte Carlo samples. Return Value real(kind=dp) The probability of having a percolating cluster, calculated as the number\n of times a percolating cluster is found, divided by the number of attempts\n ( num_samples ). Called by proc~~spanning_probability~~CalledByGraph proc~spanning_probability spanning_probability proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/spanning_probability.html","title":"spanning_probability – fortperc"},{"text":"public function spanning_probability_inverse(x, L, num_samples, tolerance) result(p_x) Find the inverse of spanning_probability by use\n of the bisection method. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x The value of spanning_probability for which the inverse\n is calculated. integer, intent(in) :: L Size of the system. integer, intent(in) :: num_samples Number of Monte Carlo samples to use when evaluating spanning_probability . real(kind=dp), intent(in) :: tolerance Tolerance of approximation. The return value is within tolerance /2 of the correct (but numerical) value. Return Value real(kind=dp) The inverse of spanning_probability . If spanning_probability is\n denoted \\Pi(p,L), this function returns p such\n that \\Pi(p,L)=x. Calls proc~~spanning_probability_inverse~~CallsGraph proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability spanning_probability proc~spanning_probability_inverse->proc~spanning_probability Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/spanning_probability_inverse.html","title":"spanning_probability_inverse – fortperc"},{"text":"public subroutine label(matrix, labelled_matrix, num_labels) Alternative interface to the Hoshen-Kopelman algorithm\n from the hk module, which uses a binary matrix created\n by create_binary_matrix . Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:) :: matrix Binary matrix where clusters will be identified. integer, intent(out), dimension(:,:), allocatable :: labelled_matrix Integer matrix which will store the labels of each cluster.\n Reallocated if necessary. integer, intent(out) :: num_labels Overwritten with the total number of disjoint clusters. Calls proc~~label~~CallsGraph proc~label label proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~label~~CalledByGraph proc~label label proc~probability_distribution probability_distribution proc~probability_distribution->proc~label proc~random_walkers random_walkers proc~random_walkers->proc~label proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~label Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/label.html","title":"label – fortperc"},{"text":"public subroutine cluster_number_density(p, L, num_samples, bin_mids, results, binsize_base) Calculate the number density of clusters with different sizes.\n The cluster number density is defined as\n \\begin{equation}\n      n(s,p) = \\sum_{\\text{MC-samples}}\n                   \\frac{\\text{number of clusters with size }s}\n                        {L&#94;2\\cdot\\text{number of MC-samples}}.\n \\end{equation}\n Direct calculations will usually give bad results, as there\n will be very few\n clusters with large sizes compared to the numbers of clusters\n with small sizes. This is circumvented by doing logarithmic\n binning and averaging, i.e.\n \\begin{equation}\n      n\\left([s+\\Delta s),p\\right) = \\sum_{\\text{MC-samples}}\n                   \\frac{\\text{number of clusters with size }s\n                         \\in[s,s+\\Delta s)}\n                        {\\Delta s\\cdot L&#94;2\\cdot\\text{number of MC-samples}},\n      \\label{eq:nsp}\n \\end{equation}\n where \\Delta s are logarithmically distributed. After execution, bin_mids will contain the centres of the bins. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p Probability for a given site to allow transport. integer, intent(in) :: L Percolating systems will be L\\times L. integer, intent(in) :: num_samples Results will be averaged over this number of Monte Carlo-samples.\n Sampling is parallelised. real(kind=dp), intent(out), dimension(:), allocatable :: bin_mids Centres of bins. real(kind=dp), intent(out), dimension(:), allocatable :: results Cluster number density in \\eqref{eq:nsp}. real(kind=dp), intent(in), optional :: binsize_base The edges of the logarithmically distributed bins will be\n integer powers of this number. Default: 1.5. Calls proc~~cluster_number_density~~CallsGraph proc~cluster_number_density cluster_number_density proc~label label proc~cluster_number_density->proc~label proc~create_binary_matrix create_binary_matrix proc~cluster_number_density->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~cluster_number_density->proc~find_spanning_cluster proc~find_sizes find_sizes proc~cluster_number_density->proc~find_sizes proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cluster_number_density.html","title":"cluster_number_density – fortperc"},{"text":"public function hoshen_kopelman(matrix) result(num_clusters) Hoshen-Kopelman algorithm for labelling clusters on\n a binary matrix. The function takes in a binary matrix\n (zeros and positive numbers), labels the clusters of\n positive numbers and returns the total number of clusters\n found. The argument matrix is overwritten with the labels. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:,:) :: matrix The matrix to be labelled. Return Value integer The total number of disjoint clusters labelled. Calls proc~~hoshen_kopelman~~CallsGraph proc~hoshen_kopelman hoshen_kopelman proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~hoshen_kopelman~~CalledByGraph proc~hoshen_kopelman hoshen_kopelman proc~label label proc~label->proc~hoshen_kopelman proc~probability_distribution probability_distribution proc~probability_distribution->proc~label proc~random_walkers random_walkers proc~random_walkers->proc~label proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~label Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hoshen_kopelman.html","title":"hoshen_kopelman – fortperc"},{"text":"public function uf_find(x, labels) result(y) Union-Find find algorithm:\n Find the lowest corresponding label.\n Relabelling is done when necessary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Label for which to find the lowest corresponding label. integer, intent(inout), dimension(:) :: labels List of labels. labels(i) points to the lowest\n corresponding label of label i . Return Value integer Called by proc~~uf_find~~CalledByGraph proc~uf_find uf_find proc~hoshen_kopelman hoshen_kopelman proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find proc~label label proc~label->proc~hoshen_kopelman proc~probability_distribution probability_distribution proc~probability_distribution->proc~label proc~random_walkers random_walkers proc~random_walkers->proc~label proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~label Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/uf_find.html","title":"uf_find – fortperc"},{"text":"public function uf_union(x, y, labels) result(canonical_label) Union-Find union algorithm:\n Merge two labels, return the result. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Labels to merge. integer, intent(in) :: y Labels to merge. integer, intent(inout), dimension(:) :: labels List of labels. Return Value integer Calls proc~~uf_union~~CallsGraph proc~uf_union uf_union proc~uf_find uf_find proc~uf_union->proc~uf_find Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~uf_union~~CalledByGraph proc~uf_union uf_union proc~hoshen_kopelman hoshen_kopelman proc~hoshen_kopelman->proc~uf_union proc~label label proc~label->proc~hoshen_kopelman proc~probability_distribution probability_distribution proc~probability_distribution->proc~label proc~random_walkers random_walkers proc~random_walkers->proc~label proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~label Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/uf_union.html","title":"uf_union – fortperc"},{"text":"Useful procedures when doing percolation. Used by module~~utilities~~UsedByGraph module~utilities utilities module~percolation percolation module~percolation->module~utilities module~randomwalk randomwalk module~randomwalk->module~utilities module~randomwalk->module~percolation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dp Functions stringfromint linspace find_intersection mark_percolating_with_periodic Subroutines linfit find_random_point periodic_wraparound Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(1.0d0) Kind used for all real variables. Functions public function stringfromint (x) Make a string of \"correct\" length from a positive integer. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Positive integer to be converted. Return Value character(len=:),\n  allocatable String containing the given integer, without spaces. public function linspace (a, b, N) Create an array of N linearly spaced values (not intervals)\n from a to b .\n Similar to numpy.linspace(a, b, N) . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a Lower endpoint. real(kind=dp), intent(in) :: b Upper endpoint. integer, intent(in) :: N Number of values (not intervals). Return Value real(kind=dp),\n  dimension(:), allocatable Array of linearly spaced values. public function find_intersection (array1, array2, num_labels) result(intersect_label) Find the common element in two arrays, given a total of num_labels unique elements. Used by find_spanning_cluster . Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array1 Array to analyse. integer, intent(in), dimension(:) :: array2 Array to analyse. integer, intent(in) :: num_labels The known number of unique non-zero elements. Return Value integer The first non-zero common element. public function mark_percolating_with_periodic (label_matrix, percolating_label, num_clusters) result(matrix) Return a logical matrix where the .true. values are the sites\n belonging to the percolating cluster, when periodic boundary\n conditions are considered. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: label_matrix Labelled matrix from label or hoshen_kopelman . integer, intent(in) :: percolating_label Known label of the percolating cluster. integer, intent(in) :: num_clusters The known number of clusters. Return Value logical,\n  dimension(:,:), allocatable Matrix where the .true. values are the sites belonging to\n the percolating cluster with periodic boundary conditions. Subroutines public subroutine linfit (x, y, slope, const) Compute a linear fit for the given data, return\n the slope and the constant term. dgels from LAPACK solves the linear least squares problem. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Values to be fitted. real(kind=dp), intent(in), dimension(:) :: y Values to be fitted. real(kind=dp), intent(inout) :: slope a in y=ax+b. real(kind=dp), intent(inout) :: const b in y=ax+b. public subroutine find_random_point (matrix, i, j) Find a random position on matrix such that matrix(i, j) is .true. . Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:) :: matrix Matrix whose .true. values are allowed positions for the\n random walker. integer, intent(out) :: i Returned random point on matrix . integer, intent(out) :: j Returned random point on matrix . public subroutine periodic_wraparound (x, L) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: x integer, intent(in) :: L","tags":"","loc":"module/utilities.html","title":"utilities – fortperc"},{"text":"Uses utilities percolation module~~randomwalk~~UsesGraph module~randomwalk randomwalk module~percolation percolation module~randomwalk->module~percolation module~utilities utilities module~randomwalk->module~utilities module~percolation->module~utilities module~hk hk module~percolation->module~hk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions one_random_walker random_walkers probability_distribution Functions public function one_random_walker (matrix, num_steps) result(displacement) Let one random walker do num_steps jumps on the .true. values of matrix . The initial position is randomly selected. Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:) :: matrix Matrix whose .true. values are allowed positions for the\n random walker. integer :: num_steps Number of steps for the random walker to take. Return Value real(kind=dp),\n  dimension(:,:), allocatable Array of displacements, which has dimension\n 2 \\times ( num_steps + 1),\n and should logically have dimension(2,0:num_steps) , such that\n the i'th column contains the displacement after i steps.\n Averaged over all systems and all walkers. public function random_walkers (p, L, num_systems, num_walkers, num_steps) result(displacement) Start num_walkers on the percolating cluster of each of num_systems systems, and return the averaged displacement. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p The probability for each site to allow transport. integer, intent(in) :: L The system size. integer, intent(in) :: num_systems The number of systems over which to average. integer, intent(in) :: num_walkers The number of random walkers for each system over which to average. integer, intent(in) :: num_steps The number of steps which the random walkers take. Return Value real(kind=dp),\n  dimension(:), allocatable Array of squared displacements, which has dimension\n ( num_steps + 1),\n and should logically have dimension(0:num_steps) , such that\n the i'th element contains the displacement after i steps.\n Averaged over all systems and all walkers. public function probability_distribution (p, L, num_steps, num_walkers, num_systems, num_hists) result(result_hist) Start num_walkers on the percolating cluster of each of num_systems systems, and compute num_hists histograms of the distribution\n of particles. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p The probability for each site to allow transport. integer, intent(in) :: L The system size. integer, intent(in) :: num_steps The number of steps which the random walkers take. integer, intent(in) :: num_walkers The number of random walkers for each system over which to average. integer, intent(in) :: num_systems The number of systems over which to average. integer, intent(in) :: num_hists The number of histograms to be returned. Return Value real(kind=dp),\n  dimension(:,:), allocatable Array of histograms. The first row contains the centres of the\n bins, while the remaining num_hists+1 rows each contain\n one histogram.","tags":"","loc":"module/randomwalk.html","title":"randomwalk – fortperc"},{"text":"A module with procedures for calculating various properties which\n are interesting when doing numerical percolation experiments. Uses utilities hk module~~percolation~~UsesGraph module~percolation percolation module~utilities utilities module~percolation->module~utilities module~hk hk module~percolation->module~hk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~percolation~~UsedByGraph module~percolation percolation module~randomwalk randomwalk module~randomwalk->module~percolation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pc Functions create_binary_matrix find_sizes find_spanning_cluster spanning_density spanning_probability spanning_probability_inverse Subroutines label cluster_number_density Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pc = 0.592746 Known critical probability for a two-dimensional site-percolating\n system. Functions public function create_binary_matrix (p, L) result(binary_matrix) Create a random, binary ( logical ) matrix,\n which can be used in percolation experiments. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p Probability for each matrix element to be .true. . integer, intent(in) :: L Return Value logical,\n  dimension(:,:), allocatable Randomly created matrix, where each element is .true. or .false. if a randomly generated number is smaller\n or greater than p. public function find_sizes (labelled_matrix, num_labels) result(sizes) Count the number of sites belonging to each cluster\n in the labelled matrix. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: labelled_matrix Integer matrix with labelled clusters, resulting from\n the Hoshen-Kopelman algorithm. integer, intent(in) :: num_labels The known number of clusters. Return Value integer,\n  dimension(:), allocatable Array of cluster sizes. The i'th element is the size of\n the cluster with label i. public function find_spanning_cluster (labelled_matrix, num_labels) result(spanning_label) Find the label of the percolating cluster, i.e. the one spanning from\n one side of the system to the opposing side. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: labelled_matrix Labelled matrix of clusters from hoshen_kopelman / label . integer, intent(in) :: num_labels Known number of clusters. Return Value integer Label of the percolating cluster. -1 if no percolating cluster is found. public function spanning_density (p, L, num_samples) Density of the spanning/percolating cluster, i.e.\n the number of sites on the percolating cluster divided by L&#94;2.\n Averaged over num_samples Monte Carlo samples (with OpenMP). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p The probability for a site to allow transport. integer, intent(in) :: L The size of the system. integer, intent(in) :: num_samples The number of Monte Carlo samples. Return Value real(kind=dp) The number of sites on the spanning cluster divided by L&#94;2. public function spanning_probability (p, L, num_samples) Calculate the probability of having a spanning/percolating cluster, given\n a system size L and probability for a site to have transport p . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p Probability for a site to allow transport. integer, intent(in) :: L Size of the system. integer, intent(in) :: num_samples Number of Monte Carlo samples. Return Value real(kind=dp) The probability of having a percolating cluster, calculated as the number\n of times a percolating cluster is found, divided by the number of attempts\n ( num_samples ). public function spanning_probability_inverse (x, L, num_samples, tolerance) result(p_x) Find the inverse of spanning_probability by use\n of the bisection method. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x The value of spanning_probability for which the inverse\n is calculated. integer, intent(in) :: L Size of the system. integer, intent(in) :: num_samples Number of Monte Carlo samples to use when evaluating spanning_probability . real(kind=dp), intent(in) :: tolerance Tolerance of approximation. The return value is within tolerance /2 of the correct (but numerical) value. Return Value real(kind=dp) The inverse of spanning_probability . If spanning_probability is\n denoted \\Pi(p,L), this function returns p such\n that \\Pi(p,L)=x. Subroutines public subroutine label (matrix, labelled_matrix, num_labels) Alternative interface to the Hoshen-Kopelman algorithm\n from the hk module, which uses a binary matrix created\n by create_binary_matrix . Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:) :: matrix Binary matrix where clusters will be identified. integer, intent(out), dimension(:,:), allocatable :: labelled_matrix Integer matrix which will store the labels of each cluster.\n Reallocated if necessary. integer, intent(out) :: num_labels Overwritten with the total number of disjoint clusters. public subroutine cluster_number_density (p, L, num_samples, bin_mids, results, binsize_base) Calculate the number density of clusters with different sizes.\n The cluster number density is defined as\n \\begin{equation}\n      n(s,p) = \\sum_{\\text{MC-samples}}\n                   \\frac{\\text{number of clusters with size }s}\n                        {L&#94;2\\cdot\\text{number of MC-samples}}.\n \\end{equation}\n Direct calculations will usually give bad results, as there\n will be very few\n clusters with large sizes compared to the numbers of clusters\n with small sizes. This is circumvented by doing logarithmic\n binning and averaging, i.e.\n \\begin{equation}\n      n\\left([s+\\Delta s),p\\right) = \\sum_{\\text{MC-samples}}\n                   \\frac{\\text{number of clusters with size }s\n                         \\in[s,s+\\Delta s)}\n                        {\\Delta s\\cdot L&#94;2\\cdot\\text{number of MC-samples}},\n      \\label{eq:nsp}\n \\end{equation}\n where \\Delta s are logarithmically distributed. After execution, bin_mids will contain the centres of the bins. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p Probability for a given site to allow transport. integer, intent(in) :: L Percolating systems will be L\\times L. integer, intent(in) :: num_samples Results will be averaged over this number of Monte Carlo-samples.\n Sampling is parallelised. real(kind=dp), intent(out), dimension(:), allocatable :: bin_mids Centres of bins. real(kind=dp), intent(out), dimension(:), allocatable :: results Cluster number density in \\eqref{eq:nsp}. real(kind=dp), intent(in), optional :: binsize_base The edges of the logarithmically distributed bins will be\n integer powers of this number. Default: 1.5.","tags":"","loc":"module/percolation.html","title":"percolation – fortperc"},{"text":"A module containing a Fortran implementation of the\n Hoshen-Kopelman algorithm, as well as the necessary\n union-find procedures. Used by module~~hk~~UsedByGraph module~hk hk module~percolation percolation module~percolation->module~hk module~randomwalk randomwalk module~randomwalk->module~percolation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions hoshen_kopelman uf_find uf_union Functions public function hoshen_kopelman (matrix) result(num_clusters) Hoshen-Kopelman algorithm for labelling clusters on\n a binary matrix. Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:,:) :: matrix The matrix to be labelled. Return Value integer The total number of disjoint clusters labelled. public function uf_find (x, labels) result(y) Union-Find find algorithm:\n Find the lowest corresponding label.\n Relabelling is done when necessary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Label for which to find the lowest corresponding label. integer, intent(inout), dimension(:) :: labels List of labels. labels(i) points to the lowest\n corresponding label of label i . Return Value integer public function uf_union (x, y, labels) result(canonical_label) Union-Find union algorithm:\n Merge two labels, return the result. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Labels to merge. integer, intent(in) :: y Labels to merge. integer, intent(inout), dimension(:) :: labels List of labels. Return Value integer","tags":"","loc":"module/hk.html","title":"hk – fortperc"}]}