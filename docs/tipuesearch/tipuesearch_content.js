var tipuesearch = {"pages":[{"title":" fortperc ","text":"fortperc This library consists of two main modules: hk , which contains an implementation of the Hoshen-Kopelman algorithm. percolation , which contains procedures for doing various percolation related measurements, such as the probability for having a percolating cluster (one which allows transport across the system). Additionally, there is utilities , a small module containing utility procedures such as linspace and linfit . Developer Info Anders Johansson","tags":"","loc":"index.html"},{"title":"utilities.f90 – fortperc","text":"Files Dependent On This One sourcefile~~utilities.f90~~AfferentGraph sourcefile~utilities.f90 utilities.f90 sourcefile~percolation.f90 percolation.f90 sourcefile~utilities.f90->sourcefile~percolation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules utilities Source Code utilities.f90 Source Code module utilities implicit none integer , parameter :: dp = kind ( 1.0d0 ) contains function stringfromint ( x ) character ( len = :), allocatable :: stringfromint integer , intent ( in ) :: x integer :: numdigits numdigits = int ( log10 ( real ( x ))) + 1 allocate ( character ( len = numdigits ) :: stringfromint ) write ( unit = stringfromint , fmt = \"(i0)\" ) x end function function linspace ( a , b , N ) integer , intent ( in ) :: N real ( kind = dp ), intent ( in ) :: a , b real ( kind = dp ), dimension (:), allocatable :: linspace real ( kind = dp ) :: dx integer :: i dx = ( b - a ) / ( N - 1 ) linspace = [ ( a + i * dx , i = 0 , N - 1 ) ] end function subroutine linfit ( x , y , slope , const ) real ( kind = dp ), dimension (:), intent ( in ) :: x , y real ( kind = dp ), intent ( in out ) :: slope , const real ( kind = dp ), dimension (:,:), allocatable :: A real ( kind = dp ), dimension (:), allocatable :: b , work integer :: lda , ldb , lwork , info , m m = size ( x ) allocate ( A ( m , 2 )) allocate ( b ( m )) allocate ( work ( 1 )) A (:, 1 ) = x (:) A (:, 2 ) = 1 b (:) = y (:) lda = m ldb = m lwork = - 1 call dgels ( \"N\" , m , 2 , 1 , A , lda , b , ldb , work , lwork , info ) lwork = int ( work ( 1 )) deallocate ( work ) allocate ( work ( lwork )) call dgels ( \"N\" , m , 2 , 1 , A , lda , b , ldb , work , lwork , info ) slope = b ( 1 ) const = b ( 2 ) if ( info /= 0 ) then error stop \"Problems with least squares\" endif end subroutine end module","tags":"","loc":"sourcefile/utilities.f90.html"},{"title":"hk.f90 – fortperc","text":"Files Dependent On This One sourcefile~~hk.f90~~AfferentGraph sourcefile~hk.f90 hk.f90 sourcefile~percolation.f90 percolation.f90 sourcefile~hk.f90->sourcefile~percolation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules hk Source Code hk.f90 Source Code module hk implicit none contains function uf_find ( x , labels ) result ( y ) !! Union-Find find algorithm: !! Find the lowest corresponding label. !! Relabelling is done when necessary. integer , intent ( in ) :: x integer , dimension (:), intent ( inout ) :: labels integer :: y , z , tmp y = x do while ( labels ( y ) /= y ) y = labels ( y ) end do tmp = x do while ( labels ( tmp ) /= tmp ) z = labels ( tmp ) labels ( tmp ) = y tmp = z end do end function function uf_union ( x , y , labels ) result ( canonical_label ) !! Union-Find union algorithm: !! Merge two labels, return the result. integer , intent ( in ) :: x , y integer , dimension (:), intent ( inout ) :: labels integer :: canonical_label canonical_label = uf_find ( y , labels ) labels ( uf_find ( x , labels )) = canonical_label end function function hoshen_kopelman ( matrix ) result ( num_clusters ) !! Hoshen-Kopelman algorithm for labelling clusters on !! a binary matrix. !! !! The function takes in a binary matrix !! (zeros and positive numbers), labels the clusters of !! positive numbers and returns the total number of clusters !! found. The argument matrix is overwritten with the labels. integer , intent ( inout ), dimension (:,:) :: matrix !! The matrix to be labelled. integer :: num_clusters !! The total number of disjoint clusters labelled. integer :: m , n , i , j , up , left , label integer , dimension (:), allocatable :: labels , new_labels m = size ( matrix , 1 ) n = size ( matrix , 2 ) allocate ( labels ( m * n / 2 + 1 )) labels = 0 num_clusters = 0 do j = 1 , n do i = 1 , m if ( matrix ( i , j ) > 0 ) then if ( i == 1 ) then up = 0 else up = matrix ( i - 1 , j ) end if if ( j == 1 ) then left = 0 else left = matrix ( i , j - 1 ) end if ! New cluster if ( up == 0 . and . left == 0 ) then num_clusters = num_clusters + 1 labels ( num_clusters ) = num_clusters matrix ( i , j ) = num_clusters ! Site binds clusters else if ( up > 0 . and . left > 0 ) then matrix ( i , j ) = uf_union ( up , left , labels ) ! Only one neighbour else matrix ( i , j ) = max ( up , left ) end if end if end do end do allocate ( new_labels ( m * n / 2 + 1 )) new_labels = 0 num_clusters = 0 do j = 1 , n do i = 1 , m if ( matrix ( i , j ) > 0 ) then label = uf_find ( matrix ( i , j ), labels ) if ( new_labels ( label ) == 0 ) then num_clusters = num_clusters + 1 new_labels ( label ) = num_clusters end if matrix ( i , j ) = new_labels ( label ) end if end do end do end function end module hk","tags":"","loc":"sourcefile/hk.f90.html"},{"title":"percolation.f90 – fortperc","text":"This File Depends On sourcefile~~percolation.f90~~EfferentGraph sourcefile~percolation.f90 percolation.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~utilities.f90->sourcefile~percolation.f90 sourcefile~hk.f90 hk.f90 sourcefile~hk.f90->sourcefile~percolation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules percolation Source Code percolation.f90 Source Code module percolation use utilities use hk implicit none real ( kind = dp ), parameter :: pc = 0.592746 contains !> C function create_binary_matrix ( p , L ) result ( binary_matrix ) logical , dimension (:,:), allocatable :: binary_matrix real ( kind = dp ), intent ( in ) :: p integer , intent ( in ) :: L real ( kind = dp ), dimension (:,:), allocatable :: p_matrix allocate ( p_matrix ( L , L )) call random_seed () call random_number ( p_matrix ) binary_matrix = p_matrix < p end function subroutine label ( matrix , labelled_matrix , num_labels ) use , intrinsic :: iso_c_binding , only : c_int logical , dimension (:,:), allocatable , intent ( in ) :: matrix integer ( c_int ), dimension (:,:), allocatable , intent ( inout ) :: labelled_matrix integer , intent ( inout ) :: num_labels integer :: L L = size ( matrix , 1 ) if (. not . allocated ( labelled_matrix )) then allocate ( labelled_matrix ( L , L )) else if ( size ( labelled_matrix , 1 ) /= L ) then deallocate ( labelled_matrix ) allocate ( labelled_matrix ( L , L )) endif where ( matrix ) labelled_matrix = 1 else where labelled_matrix = 0 end where num_labels = hoshen_kopelman ( labelled_matrix ) end subroutine function find_sizes ( labelled_matrix , num_labels ) result ( sizes ) integer , dimension (:), allocatable :: sizes integer , dimension (:,:), intent ( in ) :: labelled_matrix integer , intent ( in ) :: num_labels integer :: L , i , j L = size ( labelled_matrix , 1 ) allocate ( sizes ( num_labels )) sizes (:) = 0 do j = 1 , L do i = 1 , L associate ( label => labelled_matrix ( i , j )) if ( label /= 0 ) then sizes ( label ) = sizes ( label ) + 1 end if end associate end do end do end function subroutine cluster_number_density ( p , L , num_samples , bin_mids , results ) integer , intent ( in ) :: L , num_samples real ( kind = dp ), intent ( in ) :: p real ( kind = dp ), dimension (:), intent ( inout ), allocatable :: bin_mids , results integer :: num_bins , i , j , num_labels , sizeindex , spanning_label real ( kind = dp ) :: a , loga logical , dimension (:,:), allocatable :: binary_matrix integer , dimension (:,:), allocatable :: label_matrix integer , dimension (:), allocatable :: clustersizes , histogram real ( kind = dp ), dimension (:), allocatable :: bin_edges , bin_sizes !/cndstart/! a = 1.5d0 loga = log ( a ) num_bins = ceiling ( log ( 1.0d0 * L ** 2 ) / loga ) bin_edges = a ** [( i , i = 0 , num_bins )] bin_mids = 0.5 * ( bin_edges ( 1 : num_bins ) + bin_edges ( 2 : num_bins + 1 )) bin_sizes = bin_edges ( 2 : num_bins + 1 ) - bin_edges ( 1 : num_bins ) allocate ( histogram ( 1 : num_bins )) histogram = 0 !$omp  parallel do & !$omp& private(binary_matrix, label_matrix, num_labels, & !$omp&         clustersizes, spanning_label, sizeindex) & !$omp& reduction(+:histogram) do i = 1 , num_samples binary_matrix = create_binary_matrix ( p , L ) call label ( binary_matrix , label_matrix , num_labels ) clustersizes = find_sizes ( label_matrix , num_labels ) spanning_label = find_spanning_cluster ( label_matrix , num_labels ) do j = 1 , num_labels if ( j /= spanning_label ) then sizeindex = floor ( log ( 1.0d0 * clustersizes ( j )) / loga ) + 1 histogram ( sizeindex ) = histogram ( sizeindex ) + 1 end if end do end do !$omp end parallel do results = histogram / ( L ** 2 * num_samples * bin_sizes ) !/cndend/! end subroutine function find_spanning_cluster ( labelled_matrix , num_labels ) result ( spanning_label ) integer :: spanning_label integer , dimension (:,:), allocatable , intent ( in ) :: labelled_matrix integer , intent ( in ) :: num_labels integer :: L L = size ( labelled_matrix , 1 ) spanning_label = find_intersection ( labelled_matrix (:, 1 ), labelled_matrix (:, L ), num_labels ) if ( spanning_label == - 1 ) then spanning_label = find_intersection ( labelled_matrix ( 1 ,:), labelled_matrix ( L ,:), num_labels ) end if end function function find_intersection ( array1 , array2 , num_labels ) result ( intersect_label ) integer , dimension (:), intent ( in ) :: array1 , array2 integer :: intersect_label integer , intent ( in ) :: num_labels integer :: L , i logical , dimension (:), allocatable :: label_found L = size ( array1 ) allocate ( label_found ( 0 : num_labels )) !/intersectsnippetstart/! label_found ( 0 : num_labels ) = . false . do i = 1 , L label_found ( array1 ( i )) = . true . end do do i = 1 , L if ( array2 ( i ) /= 0 . and . label_found ( array2 ( i ))) then intersect_label = array2 ( i ) return end if end do !/intersectsnippetend/! intersect_label = - 1 end function function spanning_density_one_sample ( p , L ) result ( spanning_density ) real ( kind = dp ) :: spanning_density real ( kind = dp ), intent ( in ) :: p integer , intent ( in ) :: L logical , dimension (:,:), allocatable :: binary_matrix integer , dimension (:,:), allocatable :: labelled_matrix integer :: num_labels , spanning_label binary_matrix = create_binary_matrix ( p , L ) call label ( binary_matrix , labelled_matrix , num_labels ) spanning_label = find_spanning_cluster ( labelled_matrix , num_labels ) if ( spanning_label == - 1 ) then spanning_density = 0 return end if spanning_density = count ( labelled_matrix == spanning_label ) / real ( L ** 2 , kind = dp ) end function function spanning_density ( p , L , num_samples ) real ( kind = dp ) :: spanning_density real ( kind = dp ), intent ( in ) :: p integer , intent ( in ) :: L , num_samples integer :: i real ( kind = dp ), dimension (:), allocatable :: results allocate ( results ( num_samples )) !$omp parallel do do i = 1 , num_samples results ( i ) = spanning_density_one_sample ( p , L ) end do !$omp end parallel do spanning_density = sum ( results ) / num_samples end function function has_spanning_cluster_one_sample ( p , L ) result ( has_spanning ) logical :: has_spanning real ( kind = dp ), intent ( in ) :: p integer , intent ( in ) :: L logical , dimension (:,:), allocatable :: binary_matrix integer , dimension (:,:), allocatable :: labelled_matrix integer :: num_labels , spanning_label binary_matrix = create_binary_matrix ( p , L ) call label ( binary_matrix , labelled_matrix , num_labels ) spanning_label = find_spanning_cluster ( labelled_matrix , num_labels ) has_spanning = spanning_label /= - 1 end function function spanning_probability ( p , L , num_samples ) real ( kind = dp ) :: spanning_probability real ( kind = dp ), intent ( in ) :: p integer , intent ( in ) :: L , num_samples integer :: i logical , dimension (:), allocatable :: results allocate ( results ( num_samples )) !$omp parallel do do i = 1 , num_samples results ( i ) = has_spanning_cluster_one_sample ( p , L ) end do !$omp end parallel do spanning_probability = count ( results ) / real ( num_samples , kind = dp ) end function function spanning_probability_inverse ( x , L , num_samples , tolerance ) result ( p_x ) real ( kind = dp ), intent ( in ) :: x , tolerance real ( kind = dp ) :: p_x integer , intent ( in ) :: L , num_samples real ( kind = dp ) :: lower , upper , lowerPI , upperPI , mid , midPI !/invPIstart/! lower = 0 upper = 1 lowerPI = 0 upperPI = 1 do while ( upper - lower > tolerance ) mid = ( lower + upper ) / 2 midPI = spanning_probability ( mid , L , num_samples ) if ( midPI > x ) then upper = mid upperPI = midPI else lower = mid lowerPI = midPI end if end do p_x = mid !/invPIend/! end function !/labelsubroutinestart/! subroutine label_stackoverflow ( matrix , labelled_matrix , num_labels ) logical , dimension (:,:), allocatable , intent ( in ) :: matrix integer , dimension (:,:), allocatable , intent ( inout ) :: labelled_matrix integer , intent ( inout ) :: num_labels integer :: L , i , j L = size ( matrix , 1 ) num_labels = 0 if (. not . allocated ( labelled_matrix )) then allocate ( labelled_matrix ( L , L )) end if labelled_matrix = 0 do j = 1 , L do i = 1 , L if ( matrix ( i , j ) . and . labelled_matrix ( i , j ) == 0 ) then num_labels = num_labels + 1 call growcluster ( matrix , labelled_matrix , i , j , num_labels ) end if end do end do end subroutine !/labelsubroutineend/! !/growclustersubroutinestart/! recursive subroutine growcluster ( matrix , labelled_matrix , i , j , label ) logical , dimension (:,:), allocatable , intent ( in ) :: matrix integer , dimension (:,:), allocatable , intent ( inout ) :: labelled_matrix integer , intent ( in ) :: i , j , label integer :: L L = size ( matrix , 1 ) labelled_matrix ( i , j ) = label if ( i < L ) then if ( matrix ( i + 1 , j ) . and . labelled_matrix ( i + 1 , j ) == 0 ) then call growcluster ( matrix , labelled_matrix , i + 1 , j , label ) end if end if if ( j < L ) then if ( matrix ( i , j + 1 ) . and . labelled_matrix ( i , j + 1 ) == 0 ) then call growcluster ( matrix , labelled_matrix , i , j + 1 , label ) end if end if if ( i > 1 ) then if ( matrix ( i - 1 , j ) . and . labelled_matrix ( i - 1 , j ) == 0 ) then call growcluster ( matrix , labelled_matrix , i - 1 , j , label ) end if end if if ( j > 1 ) then if ( matrix ( i , j - 1 ) . and . labelled_matrix ( i , j - 1 ) == 0 ) then call growcluster ( matrix , labelled_matrix , i , j - 1 , label ) end if end if end subroutine !/growclustersubroutineend/! end module percolation","tags":"","loc":"sourcefile/percolation.f90.html"},{"title":"stringfromint – fortperc","text":"public function stringfromint(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value character(len=:),\n  allocatable","tags":"","loc":"proc/stringfromint.html"},{"title":"linspace – fortperc","text":"public function linspace(a, b, N) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b integer, intent(in) :: N Return Value real(kind=dp),\n  dimension(:),allocatable","tags":"","loc":"proc/linspace.html"},{"title":"linfit – fortperc","text":"public subroutine linfit(x, y, slope, const) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(inout) :: slope real(kind=dp), intent(inout) :: const Calls proc~~linfit~~CallsGraph proc~linfit linfit dgels dgels proc~linfit->dgels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/linfit.html"},{"title":"uf_find – fortperc","text":"public function uf_find(x, labels) result(y) Union-Find find algorithm:\n Find the lowest corresponding label.\n Relabelling is done when necessary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(inout), dimension(:) :: labels Return Value integer Called By proc~~uf_find~~CalledByGraph proc~uf_find uf_find proc~hoshen_kopelman hoshen_kopelman proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find proc~label label proc~label->proc~hoshen_kopelman proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~has_spanning_cluster_one_sample->proc~label proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density_one_sample->proc~label proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~label proc~spanning_probability spanning_probability proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability proc~spanning_density spanning_density proc~spanning_density->proc~spanning_density_one_sample var panprocuf_findCalledByGraph = svgPanZoom('#procuf_findCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/uf_find.html"},{"title":"uf_union – fortperc","text":"public function uf_union(x, y, labels) result(canonical_label) Union-Find union algorithm:\n Merge two labels, return the result. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: y integer, intent(inout), dimension(:) :: labels Return Value integer Calls proc~~uf_union~~CallsGraph proc~uf_union uf_union proc~uf_find uf_find proc~uf_union->proc~uf_find Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~uf_union~~CalledByGraph proc~uf_union uf_union proc~hoshen_kopelman hoshen_kopelman proc~hoshen_kopelman->proc~uf_union proc~label label proc~label->proc~hoshen_kopelman proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~has_spanning_cluster_one_sample->proc~label proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density_one_sample->proc~label proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~label proc~spanning_probability spanning_probability proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability proc~spanning_density spanning_density proc~spanning_density->proc~spanning_density_one_sample var panprocuf_unionCalledByGraph = svgPanZoom('#procuf_unionCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/uf_union.html"},{"title":"hoshen_kopelman – fortperc","text":"public function hoshen_kopelman(matrix) result(num_clusters) Hoshen-Kopelman algorithm for labelling clusters on\n a binary matrix. The function takes in a binary matrix\n (zeros and positive numbers), labels the clusters of\n positive numbers and returns the total number of clusters\n found. The argument matrix is overwritten with the labels. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:,:) :: matrix The matrix to be labelled. Return Value integer The total number of disjoint clusters labelled. Calls proc~~hoshen_kopelman~~CallsGraph proc~hoshen_kopelman hoshen_kopelman proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~hoshen_kopelman~~CalledByGraph proc~hoshen_kopelman hoshen_kopelman proc~label label proc~label->proc~hoshen_kopelman proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~has_spanning_cluster_one_sample->proc~label proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density_one_sample->proc~label proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~label proc~spanning_probability spanning_probability proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability proc~spanning_density spanning_density proc~spanning_density->proc~spanning_density_one_sample var panprochoshen_kopelmanCalledByGraph = svgPanZoom('#prochoshen_kopelmanCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/hoshen_kopelman.html"},{"title":"create_binary_matrix – fortperc","text":"public function create_binary_matrix(p, L) result(binary_matrix) C Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L Return Value logical,\n  dimension(:,:),allocatable Called By proc~~create_binary_matrix~~CalledByGraph proc~create_binary_matrix create_binary_matrix proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~has_spanning_cluster_one_sample->proc~create_binary_matrix proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density_one_sample->proc~create_binary_matrix proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~create_binary_matrix proc~spanning_probability spanning_probability proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability proc~spanning_density spanning_density proc~spanning_density->proc~spanning_density_one_sample var panproccreate_binary_matrixCalledByGraph = svgPanZoom('#proccreate_binary_matrixCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/create_binary_matrix.html"},{"title":"find_sizes – fortperc","text":"public function find_sizes(labelled_matrix, num_labels) result(sizes) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: labelled_matrix integer, intent(in) :: num_labels Return Value integer,\n  dimension(:),allocatable Called By proc~~find_sizes~~CalledByGraph proc~find_sizes find_sizes proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~find_sizes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/find_sizes.html"},{"title":"find_spanning_cluster – fortperc","text":"public function find_spanning_cluster(labelled_matrix, num_labels) result(spanning_label) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:), allocatable :: labelled_matrix integer, intent(in) :: num_labels Return Value integer Calls proc~~find_spanning_cluster~~CallsGraph proc~find_spanning_cluster find_spanning_cluster proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~find_spanning_cluster~~CalledByGraph proc~find_spanning_cluster find_spanning_cluster proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~has_spanning_cluster_one_sample->proc~find_spanning_cluster proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density_one_sample->proc~find_spanning_cluster proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~find_spanning_cluster proc~spanning_probability spanning_probability proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability proc~spanning_density spanning_density proc~spanning_density->proc~spanning_density_one_sample var panprocfind_spanning_clusterCalledByGraph = svgPanZoom('#procfind_spanning_clusterCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/find_spanning_cluster.html"},{"title":"find_intersection – fortperc","text":"public function find_intersection(array1, array2, num_labels) result(intersect_label) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array1 integer, intent(in), dimension(:) :: array2 integer, intent(in) :: num_labels Return Value integer Called By proc~~find_intersection~~CalledByGraph proc~find_intersection find_intersection proc~find_spanning_cluster find_spanning_cluster proc~find_spanning_cluster->proc~find_intersection proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~has_spanning_cluster_one_sample->proc~find_spanning_cluster proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density_one_sample->proc~find_spanning_cluster proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~find_spanning_cluster proc~spanning_probability spanning_probability proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability proc~spanning_density spanning_density proc~spanning_density->proc~spanning_density_one_sample var panprocfind_intersectionCalledByGraph = svgPanZoom('#procfind_intersectionCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/find_intersection.html"},{"title":"spanning_density_one_sample – fortperc","text":"public function spanning_density_one_sample(p, L) result(spanning_density) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L Return Value real(kind=dp) Calls proc~~spanning_density_one_sample~~CallsGraph proc~spanning_density_one_sample spanning_density_one_sample proc~label label proc~spanning_density_one_sample->proc~label proc~create_binary_matrix create_binary_matrix proc~spanning_density_one_sample->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~spanning_density_one_sample->proc~find_spanning_cluster proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find var panprocspanning_density_one_sampleCallsGraph = svgPanZoom('#procspanning_density_one_sampleCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~spanning_density_one_sample~~CalledByGraph proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density spanning_density proc~spanning_density->proc~spanning_density_one_sample Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/spanning_density_one_sample.html"},{"title":"spanning_density – fortperc","text":"public function spanning_density(p, L, num_samples) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L integer, intent(in) :: num_samples Return Value real(kind=dp) Calls proc~~spanning_density~~CallsGraph proc~spanning_density spanning_density proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density->proc~spanning_density_one_sample proc~label label proc~spanning_density_one_sample->proc~label proc~create_binary_matrix create_binary_matrix proc~spanning_density_one_sample->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~spanning_density_one_sample->proc~find_spanning_cluster proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find var panprocspanning_densityCallsGraph = svgPanZoom('#procspanning_densityCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/spanning_density.html"},{"title":"has_spanning_cluster_one_sample – fortperc","text":"public function has_spanning_cluster_one_sample(p, L) result(has_spanning) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L Return Value logical Calls proc~~has_spanning_cluster_one_sample~~CallsGraph proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~label label proc~has_spanning_cluster_one_sample->proc~label proc~create_binary_matrix create_binary_matrix proc~has_spanning_cluster_one_sample->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~has_spanning_cluster_one_sample->proc~find_spanning_cluster proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find var panprochas_spanning_cluster_one_sampleCallsGraph = svgPanZoom('#prochas_spanning_cluster_one_sampleCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~has_spanning_cluster_one_sample~~CalledByGraph proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~spanning_probability spanning_probability proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/has_spanning_cluster_one_sample.html"},{"title":"spanning_probability – fortperc","text":"public function spanning_probability(p, L, num_samples) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L integer, intent(in) :: num_samples Return Value real(kind=dp) Calls proc~~spanning_probability~~CallsGraph proc~spanning_probability spanning_probability proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~label label proc~has_spanning_cluster_one_sample->proc~label proc~create_binary_matrix create_binary_matrix proc~has_spanning_cluster_one_sample->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~has_spanning_cluster_one_sample->proc~find_spanning_cluster proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find var panprocspanning_probabilityCallsGraph = svgPanZoom('#procspanning_probabilityCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~spanning_probability~~CalledByGraph proc~spanning_probability spanning_probability proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/spanning_probability.html"},{"title":"spanning_probability_inverse – fortperc","text":"public function spanning_probability_inverse(x, L, num_samples, tolerance) result(p_x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: L integer, intent(in) :: num_samples real(kind=dp), intent(in) :: tolerance Return Value real(kind=dp) Calls proc~~spanning_probability_inverse~~CallsGraph proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability spanning_probability proc~spanning_probability_inverse->proc~spanning_probability proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~label label proc~has_spanning_cluster_one_sample->proc~label proc~create_binary_matrix create_binary_matrix proc~has_spanning_cluster_one_sample->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~has_spanning_cluster_one_sample->proc~find_spanning_cluster proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find var panprocspanning_probability_inverseCallsGraph = svgPanZoom('#procspanning_probability_inverseCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/spanning_probability_inverse.html"},{"title":"label – fortperc","text":"public subroutine label(matrix, labelled_matrix, num_labels) Uses: iso_c_binding proc~~label~~UsesGraph proc~label label iso_c_binding iso_c_binding iso_c_binding->proc~label Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:), allocatable :: matrix integer(kind=c_int), intent(inout), dimension(:,:), allocatable :: labelled_matrix integer, intent(inout) :: num_labels Calls proc~~label~~CallsGraph proc~label label proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~label~~CalledByGraph proc~label label proc~has_spanning_cluster_one_sample has_spanning_cluster_one_sample proc~has_spanning_cluster_one_sample->proc~label proc~spanning_density_one_sample spanning_density_one_sample proc~spanning_density_one_sample->proc~label proc~cluster_number_density cluster_number_density proc~cluster_number_density->proc~label proc~spanning_probability spanning_probability proc~spanning_probability->proc~has_spanning_cluster_one_sample proc~spanning_probability_inverse spanning_probability_inverse proc~spanning_probability_inverse->proc~spanning_probability proc~spanning_density spanning_density proc~spanning_density->proc~spanning_density_one_sample var panproclabelCalledByGraph = svgPanZoom('#proclabelCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/label.html"},{"title":"cluster_number_density – fortperc","text":"public subroutine cluster_number_density(p, L, num_samples, bin_mids, results) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L integer, intent(in) :: num_samples real(kind=dp), intent(inout), dimension(:), allocatable :: bin_mids real(kind=dp), intent(inout), dimension(:), allocatable :: results Calls proc~~cluster_number_density~~CallsGraph proc~cluster_number_density cluster_number_density proc~find_sizes find_sizes proc~cluster_number_density->proc~find_sizes proc~label label proc~cluster_number_density->proc~label proc~create_binary_matrix create_binary_matrix proc~cluster_number_density->proc~create_binary_matrix proc~find_spanning_cluster find_spanning_cluster proc~cluster_number_density->proc~find_spanning_cluster proc~hoshen_kopelman hoshen_kopelman proc~label->proc~hoshen_kopelman proc~find_intersection find_intersection proc~find_spanning_cluster->proc~find_intersection proc~uf_find uf_find proc~hoshen_kopelman->proc~uf_find proc~uf_union uf_union proc~hoshen_kopelman->proc~uf_union proc~uf_union->proc~uf_find var panproccluster_number_densityCallsGraph = svgPanZoom('#proccluster_number_densityCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cluster_number_density.html"},{"title":"label_stackoverflow – fortperc","text":"public subroutine label_stackoverflow(matrix, labelled_matrix, num_labels) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:), allocatable :: matrix integer, intent(inout), dimension(:,:), allocatable :: labelled_matrix integer, intent(inout) :: num_labels Calls proc~~label_stackoverflow~~CallsGraph proc~label_stackoverflow label_stackoverflow proc~growcluster growcluster proc~label_stackoverflow->proc~growcluster proc~growcluster->proc~growcluster Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/label_stackoverflow.html"},{"title":"growcluster – fortperc","text":"public recursive subroutine growcluster(matrix, labelled_matrix, i, j, label) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:), allocatable :: matrix integer, intent(inout), dimension(:,:), allocatable :: labelled_matrix integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: label Called By proc~~growcluster~~CalledByGraph proc~growcluster growcluster proc~growcluster->proc~growcluster proc~label_stackoverflow label_stackoverflow proc~label_stackoverflow->proc~growcluster Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/growcluster.html"},{"title":"utilities – fortperc","text":"Used By module~~utilities~~UsedByGraph module~utilities utilities module~percolation percolation module~utilities->module~percolation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables dp Functions stringfromint linspace Subroutines linfit Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(1.0d0) Functions public function stringfromint (x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value character(len=:),\n  allocatable public function linspace (a, b, N) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b integer, intent(in) :: N Return Value real(kind=dp),\n  dimension(:), allocatable Subroutines public subroutine linfit (x, y, slope, const) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(inout) :: slope real(kind=dp), intent(inout) :: const","tags":"","loc":"module/utilities.html"},{"title":"hk – fortperc","text":"Used By module~~hk~~UsedByGraph module~hk hk module~percolation percolation module~hk->module~percolation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions uf_find uf_union hoshen_kopelman Functions public function uf_find (x, labels) result(y) Union-Find find algorithm:\n Find the lowest corresponding label.\n Relabelling is done when necessary. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(inout), dimension(:) :: labels Return Value integer public function uf_union (x, y, labels) result(canonical_label) Union-Find union algorithm:\n Merge two labels, return the result. Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: y integer, intent(inout), dimension(:) :: labels Return Value integer public function hoshen_kopelman (matrix) result(num_clusters) Hoshen-Kopelman algorithm for labelling clusters on\n a binary matrix. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:,:) :: matrix The matrix to be labelled. Return Value integer The total number of disjoint clusters labelled.","tags":"","loc":"module/hk.html"},{"title":"percolation – fortperc","text":"Uses: utilities hk module~~percolation~~UsesGraph module~percolation percolation module~utilities utilities module~utilities->module~percolation module~hk hk module~hk->module~percolation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables pc Functions create_binary_matrix find_sizes find_spanning_cluster find_intersection spanning_density_one_sample spanning_density has_spanning_cluster_one_sample spanning_probability spanning_probability_inverse Subroutines label cluster_number_density label_stackoverflow growcluster Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pc = 0.592746 Functions public function create_binary_matrix (p, L) result(binary_matrix) C Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L Return Value logical,\n  dimension(:,:), allocatable public function find_sizes (labelled_matrix, num_labels) result(sizes) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: labelled_matrix integer, intent(in) :: num_labels Return Value integer,\n  dimension(:), allocatable public function find_spanning_cluster (labelled_matrix, num_labels) result(spanning_label) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:), allocatable :: labelled_matrix integer, intent(in) :: num_labels Return Value integer public function find_intersection (array1, array2, num_labels) result(intersect_label) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: array1 integer, intent(in), dimension(:) :: array2 integer, intent(in) :: num_labels Return Value integer public function spanning_density_one_sample (p, L) result(spanning_density) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L Return Value real(kind=dp) public function spanning_density (p, L, num_samples) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L integer, intent(in) :: num_samples Return Value real(kind=dp) public function has_spanning_cluster_one_sample (p, L) result(has_spanning) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L Return Value logical public function spanning_probability (p, L, num_samples) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L integer, intent(in) :: num_samples Return Value real(kind=dp) public function spanning_probability_inverse (x, L, num_samples, tolerance) result(p_x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x integer, intent(in) :: L integer, intent(in) :: num_samples real(kind=dp), intent(in) :: tolerance Return Value real(kind=dp) Subroutines public subroutine label (matrix, labelled_matrix, num_labels) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:), allocatable :: matrix integer(kind=c_int), intent(inout), dimension(:,:), allocatable :: labelled_matrix integer, intent(inout) :: num_labels public subroutine cluster_number_density (p, L, num_samples, bin_mids, results) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: p integer, intent(in) :: L integer, intent(in) :: num_samples real(kind=dp), intent(inout), dimension(:), allocatable :: bin_mids real(kind=dp), intent(inout), dimension(:), allocatable :: results public subroutine label_stackoverflow (matrix, labelled_matrix, num_labels) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:), allocatable :: matrix integer, intent(inout), dimension(:,:), allocatable :: labelled_matrix integer, intent(inout) :: num_labels public recursive subroutine growcluster (matrix, labelled_matrix, i, j, label) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:,:), allocatable :: matrix integer, intent(inout), dimension(:,:), allocatable :: labelled_matrix integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: label","tags":"","loc":"module/percolation.html"}]}